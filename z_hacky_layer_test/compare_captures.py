#!/usr/bin/env python3
"""
Script to compare captures generated by two rounds of cache_layer.py
Checks if both runs have the same number of sequence lengths and same number of passes for each sequence length.
"""

import os
import argparse
import glob
from collections import defaultdict
from pathlib import Path
import torch
import numpy as np
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend
import matplotlib.pyplot as plt

def parse_directory_structure(captures_dir):
    """Parse the captures directory structure and return organized data."""
    structure = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
    
    # Check if we're looking at a variant directory directly (contains seq_len_* directories)
    seq_dirs_in_root = glob.glob(os.path.join(captures_dir, "seq_len_*"))
    
    if seq_dirs_in_root:
        # We're at the variant level already
        backend = "unknown"
        variant = os.path.basename(captures_dir)
        
        for seq_dir in seq_dirs_in_root:
            if not os.path.isdir(seq_dir):
                continue
                
            seq_len = int(os.path.basename(seq_dir).split("_")[2])
            
            # Look for pass directories within each sequence length
            for pass_dir in glob.glob(os.path.join(seq_dir, "pass_*")):
                if not os.path.isdir(pass_dir):
                    continue
                    
                pass_num = int(os.path.basename(pass_dir).split("_")[1])
                
                # Check what files are in this directory
                files = os.listdir(pass_dir)
                structure[backend][variant][seq_len].append({
                    'pass': pass_num,
                    'files': files,
                    'path': pass_dir
                })
    else:
        # Original logic: Walk through backend/variant structure
        for backend_dir in glob.glob(os.path.join(captures_dir, "*")):
            if not os.path.isdir(backend_dir):
                continue
                
            backend = os.path.basename(backend_dir)
            
            for variant_dir in glob.glob(os.path.join(backend_dir, "*")):
                if not os.path.isdir(variant_dir):
                    continue
                    
                variant = os.path.basename(variant_dir)
                
                # Look for sequence length directories
                for seq_dir in glob.glob(os.path.join(variant_dir, "seq_len_*")):
                    if not os.path.isdir(seq_dir):
                        continue
                        
                    seq_len = int(os.path.basename(seq_dir).split("_")[2])
                    
                    # Look for pass directories within each sequence length
                    for pass_dir in glob.glob(os.path.join(seq_dir, "pass_*")):
                        if not os.path.isdir(pass_dir):
                            continue
                            
                        pass_num = int(os.path.basename(pass_dir).split("_")[1])
                        
                        # Check what files are in this directory
                        files = os.listdir(pass_dir)
                        structure[backend][variant][seq_len].append({
                            'pass': pass_num,
                            'files': files,
                            'path': pass_dir
                        })
    
    # Sort passes for each sequence length
    for backend in structure:
        for variant in structure[backend]:
            for seq_len in structure[backend][variant]:
                structure[backend][variant][seq_len].sort(key=lambda x: x['pass'])
    
    return structure

def print_structure_summary(structure, label):
    """Print a summary of the capture structure."""
    print(f"\n=== {label} ===")
    
    for backend in sorted(structure.keys()):
        print(f"Backend: {backend}")
        
        for variant in sorted(structure[backend].keys()):
            print(f"  Variant: {variant}")
            
            seq_lens = sorted(structure[backend][variant].keys())
            print(f"    Sequence lengths: {len(seq_lens)} total")
            print(f"    Range: {min(seq_lens) if seq_lens else 'N/A'} - {max(seq_lens) if seq_lens else 'N/A'}")
            
            for seq_len in seq_lens:
                passes = structure[backend][variant][seq_len]
                pass_nums = [p['pass'] for p in passes]
                print(f"      seq_len_{seq_len}: {len(passes)} passes ({min(pass_nums)}-{max(pass_nums)})")

def compare_structures(struct1, struct2, label1, label2):
    """Compare two capture structures and report differences."""
    print(f"\n=== COMPARISON: {label1} vs {label2} ===")
    
    # Special case: if both structures have only one backend and one variant each,
    # compare them directly as equivalent runs
    if (len(struct1) == 1 and len(struct2) == 1 and 
        all(len(variants) == 1 for variants in struct1.values()) and
        all(len(variants) == 1 for variants in struct2.values())):
        
        # Get the single backend/variant from each structure
        backend1, variants1 = next(iter(struct1.items()))
        variant1, data1 = next(iter(variants1.items()))
        
        backend2, variants2 = next(iter(struct2.items()))
        variant2, data2 = next(iter(variants2.items()))
        
        print(f"Comparing {label1} ({variant1}) vs {label2} ({variant2})")
        
        seq_lens1 = set(data1.keys())
        seq_lens2 = set(data2.keys())
        
        # Compare sequence lengths
        if seq_lens1 == seq_lens2:
            print(f"✅ Same sequence lengths: {len(seq_lens1)} total ({sorted(seq_lens1)})")
        else:
            print(f"❌ Different sequence lengths:")
            print(f"   {label1}: {len(seq_lens1)} ({sorted(seq_lens1)})")
            print(f"   {label2}: {len(seq_lens2)} ({sorted(seq_lens2)})")
            
            only_in_1 = seq_lens1 - seq_lens2
            only_in_2 = seq_lens2 - seq_lens1
            if only_in_1:
                print(f"   Only in {label1}: {sorted(only_in_1)}")
            if only_in_2:
                print(f"   Only in {label2}: {sorted(only_in_2)}")
        
        # Compare passes for each sequence length
        common_seq_lens = seq_lens1 & seq_lens2
        all_passes_match = True
        
        for seq_len in sorted(common_seq_lens):
            passes1 = [p['pass'] for p in data1[seq_len]]
            passes2 = [p['pass'] for p in data2[seq_len]]
            
            if passes1 == passes2:
                print(f"  ✅ seq_len_{seq_len}: Same passes ({len(passes1)} total: {passes1})")
            else:
                print(f"  ❌ seq_len_{seq_len}: Different passes")
                print(f"     {label1}: {passes1}")
                print(f"     {label2}: {passes2}")
                all_passes_match = False
        
        if common_seq_lens and all_passes_match:
            print(f"✅ All passes match for all common sequence lengths")
        elif common_seq_lens:
            print(f"❌ Some passes don't match")
        
        return
    
    # Original logic for complex structures
    # Get all backends from both structures
    all_backends = set(struct1.keys()) | set(struct2.keys())
    
    for backend in sorted(all_backends):
        print(f"\nBackend: {backend}")
        
        if backend not in struct1:
            print(f"  ❌ {backend} missing from {label1}")
            continue
        if backend not in struct2:
            print(f"  ❌ {backend} missing from {label2}")
            continue
            
        # Get all variants
        all_variants = set(struct1[backend].keys()) | set(struct2[backend].keys())
        
        for variant in sorted(all_variants):
            print(f"  Variant: {variant}")
            
            if variant not in struct1[backend]:
                print(f"    ❌ {variant} missing from {label1}")
                continue
            if variant not in struct2[backend]:
                print(f"    ❌ {variant} missing from {label2}")
                continue
            
            seq_lens1 = set(struct1[backend][variant].keys())
            seq_lens2 = set(struct2[backend][variant].keys())
            
            # Compare sequence lengths
            if seq_lens1 == seq_lens2:
                print(f"    ✅ Same sequence lengths: {len(seq_lens1)} total")
            else:
                print(f"    ❌ Different sequence lengths:")
                print(f"       {label1}: {len(seq_lens1)} ({sorted(seq_lens1)})")
                print(f"       {label2}: {len(seq_lens2)} ({sorted(seq_lens2)})")
                
                only_in_1 = seq_lens1 - seq_lens2
                only_in_2 = seq_lens2 - seq_lens1
                if only_in_1:
                    print(f"       Only in {label1}: {sorted(only_in_1)}")
                if only_in_2:
                    print(f"       Only in {label2}: {sorted(only_in_2)}")
            
            # Compare passes for each sequence length
            common_seq_lens = seq_lens1 & seq_lens2
            all_passes_match = True
            
            for seq_len in sorted(common_seq_lens):
                passes1 = [p['pass'] for p in struct1[backend][variant][seq_len]]
                passes2 = [p['pass'] for p in struct2[backend][variant][seq_len]]
                
                if passes1 == passes2:
                    print(f"      ✅ seq_len_{seq_len}: Same passes ({len(passes1)} total)")
                else:
                    print(f"      ❌ seq_len_{seq_len}: Different passes")
                    print(f"         {label1}: {passes1}")
                    print(f"         {label2}: {passes2}")
                    all_passes_match = False
            
            if common_seq_lens and all_passes_match:
                print(f"    ✅ All passes match for common sequence lengths")

def load_tensor_safely(file_path):
    """Load a tensor file safely, handling potential errors."""
    try:
        if os.path.exists(file_path):
            return torch.load(file_path, map_location='cpu')
        else:
            print(f"Warning: File not found: {file_path}")
            return None
    except Exception as e:
        print(f"Error loading {file_path}: {e}")
        return None

def compute_l2_difference(tensor1, tensor2):
    """Compute L2 norm of the difference between two tensors."""
    if tensor1 is None or tensor2 is None:
        return float('nan')
    
    try:
        # Convert to float32 for computation if needed
        if tensor1.dtype != torch.float32:
            tensor1 = tensor1.float()
        if tensor2.dtype != torch.float32:
            tensor2 = tensor2.float()
            
        # Ensure same shape
        if tensor1.shape != tensor2.shape:
            print(f"Warning: Shape mismatch: {tensor1.shape} vs {tensor2.shape}")
            return float('nan')
        
        diff = tensor1 - tensor2
        l2_norm = torch.norm(diff, p=2).item()
        return l2_norm
    except Exception as e:
        print(f"Error computing L2 difference: {e}")
        return float('nan')

def compare_tensors_across_seqlens(struct1, struct2, label1, label2):
    """Compare tensors across sequence lengths and plot L2 differences."""
    print(f"\n=== TENSOR COMPARISON: {label1} vs {label2} ===")
    
    # Extract data from structures (assuming single backend/variant each)
    if not (len(struct1) == 1 and len(struct2) == 1):
        print("Error: Expected single backend/variant in each structure")
        return
    
    backend1, variants1 = next(iter(struct1.items()))
    variant1, data1 = next(iter(variants1.items()))
    
    backend2, variants2 = next(iter(struct2.items()))
    variant2, data2 = next(iter(variants2.items()))
    
    # Get common sequence lengths
    seq_lens1 = set(data1.keys())
    seq_lens2 = set(data2.keys())
    common_seq_lens = sorted(seq_lens1 & seq_lens2)
    
    if not common_seq_lens:
        print("No common sequence lengths found")
        return
    
    print(f"Comparing tensors for sequence lengths: {common_seq_lens}")
    
    # Data for plotting
    seq_lens_plot = []
    l2_diffs_output = []
    l2_diffs_kv_cache = []
    
    for i, seq_len in enumerate(common_seq_lens):
        print(f"\nProcessing seq_len {seq_len} ({i+1}/{len(common_seq_lens)})...")
        
        # Get pass data for this sequence length
        passes1 = data1[seq_len]
        passes2 = data2[seq_len]
        
        if len(passes1) != 1 or len(passes2) != 1:
            print(f"Warning: Expected exactly 1 pass for seq_len {seq_len}, got {len(passes1)} and {len(passes2)}")
            continue
        
        pass1_data = passes1[0]
        pass2_data = passes2[0]
        
        # Compare output tensors
        print("  Loading output tensors...")
        output_path1 = os.path.join(pass1_data['path'], 'output.pt')
        output_path2 = os.path.join(pass2_data['path'], 'output.pt')
        
        output1 = load_tensor_safely(output_path1)
        output2 = load_tensor_safely(output_path2)
        
        l2_diff_output = compute_l2_difference(output1, output2)
        print(f"  Output tensor L2 diff: {l2_diff_output}")
        
        # Compare KV cache tensors
        print("  Loading KV cache tensors...")
        kv_cache_path1 = os.path.join(pass1_data['path'], 'kv_cache_post.pt')
        kv_cache_path2 = os.path.join(pass2_data['path'], 'kv_cache_post.pt')
        
        kv_cache1 = load_tensor_safely(kv_cache_path1)
        kv_cache2 = load_tensor_safely(kv_cache_path2)
        
        l2_diff_kv = compute_l2_difference(kv_cache1, kv_cache2)
        print(f"  KV cache tensor L2 diff: {l2_diff_kv}")
        
        # Store for plotting
        if not np.isnan(l2_diff_output) or not np.isnan(l2_diff_kv):
            seq_lens_plot.append(seq_len)
            l2_diffs_output.append(l2_diff_output)
            l2_diffs_kv_cache.append(l2_diff_kv)
        
        # Clear memory
        del output1, output2, kv_cache1, kv_cache2
    
    # Create plots
    if seq_lens_plot:
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))
        
        # Plot output tensor differences
        ax1.plot(seq_lens_plot, l2_diffs_output, 'bo-', linewidth=2, markersize=6)
        ax1.set_xlabel('Sequence Length')
        ax1.set_ylabel('L2 Norm Difference')
        ax1.set_title(f'Output Tensor L2 Differences: {label1} vs {label2}')
        ax1.grid(True, alpha=0.3)
        ax1.set_yscale('log')
        
        # Plot KV cache tensor differences
        ax2.plot(seq_lens_plot, l2_diffs_kv_cache, 'ro-', linewidth=2, markersize=6)
        ax2.set_xlabel('Sequence Length')
        ax2.set_ylabel('L2 Norm Difference')
        ax2.set_title(f'KV Cache Tensor L2 Differences: {label1} vs {label2}')
        ax2.grid(True, alpha=0.3)
        ax2.set_yscale('log')
        
        plt.tight_layout()
        
        # Save plot
        plot_filename = f'tensor_comparison_{variant1}_vs_{variant2}.png'
        plt.savefig(plot_filename, dpi=300, bbox_inches='tight')
        print(f"\nPlot saved as: {plot_filename}")
        plt.close()  # Close the figure to free memory
        
        # Print summary statistics
        print(f"\n=== SUMMARY STATISTICS ===")
        print(f"Output tensor L2 differences:")
        valid_output_diffs = [x for x in l2_diffs_output if not np.isnan(x)]
        if valid_output_diffs:
            print(f"  Min: {min(valid_output_diffs):.6e}")
            print(f"  Max: {max(valid_output_diffs):.6e}")
            print(f"  Mean: {np.mean(valid_output_diffs):.6e}")
            print(f"  Std: {np.std(valid_output_diffs):.6e}")
        
        print(f"KV cache tensor L2 differences:")
        valid_kv_diffs = [x for x in l2_diffs_kv_cache if not np.isnan(x)]
        if valid_kv_diffs:
            print(f"  Min: {min(valid_kv_diffs):.6e}")
            print(f"  Max: {max(valid_kv_diffs):.6e}")
            print(f"  Mean: {np.mean(valid_kv_diffs):.6e}")
            print(f"  Std: {np.std(valid_kv_diffs):.6e}")
    
    else:
        print("No valid tensor comparisons could be made")

def main():
    parser = argparse.ArgumentParser(description="Compare captures from two cache_layer.py runs")
    parser.add_argument("--captures1", type=str, required=True, help="Path to first captures directory")
    parser.add_argument("--captures2", type=str, required=True, help="Path to second captures directory")
    parser.add_argument("--label1", type=str, default="Run 1", help="Label for first run")
    parser.add_argument("--label2", type=str, default="Run 2", help="Label for second run")
    parser.add_argument("--tensor-comparison", action="store_true", help="Perform tensor comparison and plotting")
    parser.add_argument("--structure-only", action="store_true", help="Only compare directory structures, skip tensor comparison")
    
    args = parser.parse_args()
    
    # Verify directories exist
    if not os.path.exists(args.captures1):
        print(f"Error: {args.captures1} does not exist")
        return 1
    if not os.path.exists(args.captures2):
        print(f"Error: {args.captures2} does not exist")
        return 1
    
    # Parse both directory structures
    print("Parsing capture structures...")
    struct1 = parse_directory_structure(args.captures1)
    struct2 = parse_directory_structure(args.captures2)
    
    # Print summaries
    print_structure_summary(struct1, args.label1)
    print_structure_summary(struct2, args.label2)
    
    # Compare structures
    compare_structures(struct1, struct2, args.label1, args.label2)
    
    # Perform tensor comparison if requested or if not explicitly disabled
    if args.tensor_comparison or not args.structure_only:
        try:
            compare_tensors_across_seqlens(struct1, struct2, args.label1, args.label2)
        except Exception as e:
            print(f"Error during tensor comparison: {e}")
            print("Run with --structure-only to skip tensor comparison")
    
    return 0

if __name__ == "__main__":
    exit(main()) 